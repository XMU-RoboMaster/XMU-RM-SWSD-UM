{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u53a6\u95e8\u5927\u5b66\u673a\u5668\u4eba\u961f-\u8f6f\u4ef6\u6807\u51c6\u5316 \u5b9e\u65bd\u6807\u51c6\u5316\u6218\u7565 \u4ee5\u6807\u51c6\u52a9\u529b\u53d1\u5c55 Overview Introduction Hardware Support Basic Software Install Getting Started Motor Control Reference Motor Parameters FAQs How to Debug Latest Updated \uff1a2022.07.15","title":"\u53a6\u95e8\u5927\u5b66\u673a\u5668\u4eba\u961f-\u8f6f\u4ef6\u6807\u51c6\u5316"},{"location":"#-","text":"\u5b9e\u65bd\u6807\u51c6\u5316\u6218\u7565 \u4ee5\u6807\u51c6\u52a9\u529b\u53d1\u5c55","title":"\u53a6\u95e8\u5927\u5b66\u673a\u5668\u4eba\u961f-\u8f6f\u4ef6\u6807\u51c6\u5316"},{"location":"#overview","text":"Introduction Hardware Support","title":"Overview"},{"location":"#basic","text":"Software Install Getting Started Motor Control","title":"Basic"},{"location":"#reference","text":"Motor Parameters","title":"Reference"},{"location":"#faqs","text":"How to Debug","title":"FAQs"},{"location":"#latest-updated-20220715","text":"","title":"Latest Updated \uff1a2022.07.15"},{"location":"CAN-Use/","text":"CAN\u901a\u4fe1\u662f\u63a7\u5236\u7535\u673a\u8fd0\u52a8\u7684\u91cd\u8981\u901a\u4fe1\u65b9\u5f0f\u4e4b\u4e00\uff0c\u5177\u4f53\u4f7f\u7528\u65b9\u6cd5\u5982\u4e0b\uff1a can.h\u6587\u4ef6\u4e0ecan.cpp\u7684\u4f7f\u7528 can .h #pragma once #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_hal_can.h\" #include <cstdlib> #include <cstring> class CAN { public: void Init(CAN_TypeDef* instance); void InitFilter(); HAL_StatusTypeDef Transmit(const uint32_t ID, const uint8_t*const pData, const uint8_t len = 8); CAN_HandleTypeDef hcan; uint8_t data[8][8]; private: CanTxMsgTypeDef TxMessage; CanRxMsgTypeDef RxMessage; }; extern CAN can1, can2; can.cpp #include \"can.h\" #include \"PID.h\" void CAN::Init(CAN_TypeDef* instance) { hcan.Instance = instance; hcan.Init.Prescaler = 6; hcan.Init.Mode = CAN_MODE_NORMAL; hcan.Init.SJW = CAN_SJW_1TQ; hcan.Init.BS1 = CAN_BS1_2TQ; hcan.Init.BS2 = CAN_BS2_4TQ; hcan.Init.TTCM = DISABLE; hcan.Init.ABOM = ENABLE; hcan.Init.AWUM = ENABLE; hcan.Init.NART = DISABLE; hcan.Init.RFLM = DISABLE; hcan.Init.TXFP = DISABLE; HAL_CAN_Init(&hcan); HAL_CAN_Transmit_IT(&hcan); HAL_CAN_Receive_IT(&hcan, CAN_FIFO0); InitFilter(); } void CAN::InitFilter() { //can1 &can2 use same filter config CAN_FilterConfTypeDef CAN_FilterConfigStructure; CAN_FilterConfigStructure.FilterNumber = 0; CAN_FilterConfigStructure.FilterMode = CAN_FILTERMODE_IDMASK; CAN_FilterConfigStructure.FilterScale = CAN_FILTERSCALE_32BIT; CAN_FilterConfigStructure.FilterIdHigh = 0x0000; CAN_FilterConfigStructure.FilterIdLow = 0x0000; CAN_FilterConfigStructure.FilterMaskIdHigh = 0x0000; CAN_FilterConfigStructure.FilterMaskIdLow = 0x0000; CAN_FilterConfigStructure.FilterFIFOAssignment = CAN_FilterFIFO0; //can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter CAN_FilterConfigStructure.BankNumber = 0; CAN_FilterConfigStructure.FilterActivation = ENABLE; HAL_CAN_ConfigFilter(&hcan, &CAN_FilterConfigStructure); //filter config for can2 //can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter CAN_FilterConfigStructure.FilterNumber = 14; HAL_CAN_ConfigFilter(&hcan, &CAN_FilterConfigStructure); hcan.pTxMsg = &TxMessage; hcan.pRxMsg = &RxMessage; } void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan) { GPIO_InitTypeDef GPIO_InitStruct; if (hcan->Instance == CAN1) { /* Peripheral clock enable */ __HAL_RCC_CAN1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**CAN1 GPIO Configuration PD0 ------> CAN1_RX PD1 ------> CAN1_TX*/ GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_CAN1; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* Peripheral interrupt init */ HAL_NVIC_SetPriority(CAN1_TX_IRQn, 1, 0); HAL_NVIC_EnableIRQ(CAN1_TX_IRQn); HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 0, 0); HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn); } else if (hcan->Instance == CAN2) { /* Peripheral clock enable */ __HAL_RCC_CAN2_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); /**CAN1 GPIO Configuration PB12 ------> CAN2_RX PB13 ------> CAN2_TX*/ GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_CAN2; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); /* Peripheral interrupt init */ HAL_NVIC_SetPriority(CAN2_TX_IRQn, 1, 0); HAL_NVIC_EnableIRQ(CAN2_TX_IRQn); HAL_NVIC_SetPriority(CAN2_RX0_IRQn, 0, 0); HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn); } } extern \"C\" void CAN1_TX_IRQHandler() { HAL_CAN_IRQHandler(&can1.hcan); } extern \"C\" void CAN1_RX0_IRQHandler() { HAL_CAN_IRQHandler(&can1.hcan); } extern \"C\" void CAN2_TX_IRQHandler() { HAL_CAN_IRQHandler(&can2.hcan); } extern \"C\" void CAN2_RX0_IRQHandler() { HAL_CAN_IRQHandler(&can2.hcan); } HAL_StatusTypeDef CAN::Transmit(const uint32_t ID, const uint8_t*const pData, const uint8_t len) { hcan.pTxMsg->StdId = ID; hcan.pTxMsg->IDE = CAN_ID_STD; hcan.pTxMsg->RTR = CAN_RTR_DATA; hcan.pTxMsg->DLC = len; memcpy(hcan.pTxMsg->Data, pData, len); return HAL_CAN_Transmit(&hcan, 10); } void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan) { if (hcan == &can1.hcan)memcpy(can1.data[hcan->pRxMsg->StdId - 0x201], hcan->pRxMsg->Data, sizeof(uint8_t) * 8); else memcpy(can2.data[hcan->pRxMsg->StdId - 0x201], hcan->pRxMsg->Data, sizeof(uint8_t) * 8); /*#### add enable can it again to solve can receive only one ID problem!!!####**/ __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP0); } \u200b \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecCAN\u901a\u4fe1\u7684\u6536\u53d1\u65b9\u5f0f\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528CAN\u901a\u4fe1\u6765\u8fdb\u884c\u7535\u673a\u4ee3\u7801\u7684\u7f16\u5199","title":"CAN"},{"location":"CAN-Use/#canhcancpp","text":"","title":"can.h\u6587\u4ef6\u4e0ecan.cpp\u7684\u4f7f\u7528"},{"location":"CAN-Use/#can-h","text":"#pragma once #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_hal_can.h\" #include <cstdlib> #include <cstring> class CAN { public: void Init(CAN_TypeDef* instance); void InitFilter(); HAL_StatusTypeDef Transmit(const uint32_t ID, const uint8_t*const pData, const uint8_t len = 8); CAN_HandleTypeDef hcan; uint8_t data[8][8]; private: CanTxMsgTypeDef TxMessage; CanRxMsgTypeDef RxMessage; }; extern CAN can1, can2;","title":"can .h"},{"location":"CAN-Use/#cancpp","text":"#include \"can.h\" #include \"PID.h\" void CAN::Init(CAN_TypeDef* instance) { hcan.Instance = instance; hcan.Init.Prescaler = 6; hcan.Init.Mode = CAN_MODE_NORMAL; hcan.Init.SJW = CAN_SJW_1TQ; hcan.Init.BS1 = CAN_BS1_2TQ; hcan.Init.BS2 = CAN_BS2_4TQ; hcan.Init.TTCM = DISABLE; hcan.Init.ABOM = ENABLE; hcan.Init.AWUM = ENABLE; hcan.Init.NART = DISABLE; hcan.Init.RFLM = DISABLE; hcan.Init.TXFP = DISABLE; HAL_CAN_Init(&hcan); HAL_CAN_Transmit_IT(&hcan); HAL_CAN_Receive_IT(&hcan, CAN_FIFO0); InitFilter(); } void CAN::InitFilter() { //can1 &can2 use same filter config CAN_FilterConfTypeDef CAN_FilterConfigStructure; CAN_FilterConfigStructure.FilterNumber = 0; CAN_FilterConfigStructure.FilterMode = CAN_FILTERMODE_IDMASK; CAN_FilterConfigStructure.FilterScale = CAN_FILTERSCALE_32BIT; CAN_FilterConfigStructure.FilterIdHigh = 0x0000; CAN_FilterConfigStructure.FilterIdLow = 0x0000; CAN_FilterConfigStructure.FilterMaskIdHigh = 0x0000; CAN_FilterConfigStructure.FilterMaskIdLow = 0x0000; CAN_FilterConfigStructure.FilterFIFOAssignment = CAN_FilterFIFO0; //can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter CAN_FilterConfigStructure.BankNumber = 0; CAN_FilterConfigStructure.FilterActivation = ENABLE; HAL_CAN_ConfigFilter(&hcan, &CAN_FilterConfigStructure); //filter config for can2 //can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter CAN_FilterConfigStructure.FilterNumber = 14; HAL_CAN_ConfigFilter(&hcan, &CAN_FilterConfigStructure); hcan.pTxMsg = &TxMessage; hcan.pRxMsg = &RxMessage; } void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan) { GPIO_InitTypeDef GPIO_InitStruct; if (hcan->Instance == CAN1) { /* Peripheral clock enable */ __HAL_RCC_CAN1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**CAN1 GPIO Configuration PD0 ------> CAN1_RX PD1 ------> CAN1_TX*/ GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_CAN1; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* Peripheral interrupt init */ HAL_NVIC_SetPriority(CAN1_TX_IRQn, 1, 0); HAL_NVIC_EnableIRQ(CAN1_TX_IRQn); HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 0, 0); HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn); } else if (hcan->Instance == CAN2) { /* Peripheral clock enable */ __HAL_RCC_CAN2_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); /**CAN1 GPIO Configuration PB12 ------> CAN2_RX PB13 ------> CAN2_TX*/ GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_CAN2; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); /* Peripheral interrupt init */ HAL_NVIC_SetPriority(CAN2_TX_IRQn, 1, 0); HAL_NVIC_EnableIRQ(CAN2_TX_IRQn); HAL_NVIC_SetPriority(CAN2_RX0_IRQn, 0, 0); HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn); } } extern \"C\" void CAN1_TX_IRQHandler() { HAL_CAN_IRQHandler(&can1.hcan); } extern \"C\" void CAN1_RX0_IRQHandler() { HAL_CAN_IRQHandler(&can1.hcan); } extern \"C\" void CAN2_TX_IRQHandler() { HAL_CAN_IRQHandler(&can2.hcan); } extern \"C\" void CAN2_RX0_IRQHandler() { HAL_CAN_IRQHandler(&can2.hcan); } HAL_StatusTypeDef CAN::Transmit(const uint32_t ID, const uint8_t*const pData, const uint8_t len) { hcan.pTxMsg->StdId = ID; hcan.pTxMsg->IDE = CAN_ID_STD; hcan.pTxMsg->RTR = CAN_RTR_DATA; hcan.pTxMsg->DLC = len; memcpy(hcan.pTxMsg->Data, pData, len); return HAL_CAN_Transmit(&hcan, 10); } void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan) { if (hcan == &can1.hcan)memcpy(can1.data[hcan->pRxMsg->StdId - 0x201], hcan->pRxMsg->Data, sizeof(uint8_t) * 8); else memcpy(can2.data[hcan->pRxMsg->StdId - 0x201], hcan->pRxMsg->Data, sizeof(uint8_t) * 8); /*#### add enable can it again to solve can receive only one ID problem!!!####**/ __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP0); } \u200b \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecCAN\u901a\u4fe1\u7684\u6536\u53d1\u65b9\u5f0f\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528CAN\u901a\u4fe1\u6765\u8fdb\u884c\u7535\u673a\u4ee3\u7801\u7684\u7f16\u5199","title":"can.cpp"},{"location":"Getting-Started/","text":"\u57fa\u7840\u5165\u95e8 \u70b9\u4eae\u7b2c\u4e00\u76cfled\u706f #\u9996\u5148\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5de5\u7a0b\u6587\u6863\uff0c\u7136\u540e\u5c06\u4f1a\u5f97\u5230\u4e00\u4e0b\u5de5\u7a0b\u6a21\u677f #include \"stm32f4xx_hal.h\" #include \"can.h\" #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } //\u4ee5\u4e0a\u4e3a\u5934\u6587\u4ef6\u52a0\u8f7d\u4e0e\u7cfb\u7edf\u8ba1\u65f6\u5668\u3001\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u521d\u59cb\u5316 int main(void) //\u4e3b\u51fd\u6570\uff0c\u70b9\u4eaeLED\u706f\u7684\u91cd\u70b9 { HAL_Init(); //HAL\u5e93\u51fd\u6570\u7684\u521d\u59cb\u5316 __GPIOD_CLK_ENABLE(); //\u521d\u59cb\u5316GPIO\u5bf9\u5e94\u7ec4\u7684\u65f6\u949f\uff0c\u9700\u8981\u67e5\u770b\u539f\u7406\u56fe\u627e\u5230\u60f3\u8981\u4f7f\u80fd\u7684GPIO\u53e3\u7684\u7ec4\u522b\uff08\u7ec4\u522b\u4eceA-G\uff09 GPIO_InitTypeDef GPIO_InitStructure; //\u5b9a\u4e49\u4e00\u4e2aGPIO\u521d\u59cb\u5316\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u914d\u7f6e\u76f8\u5173\u5bc4\u5b58\u5668 GPIO_InitStructure.Pin = GPIO_PIN_12; //pin\u811a\u7684\u8bbe\u7f6e\uff0c\u9700\u8981\u67e5\u770b\u539f\u7406\u56fe\u5f97\u5230\u5bf9\u5e94pin\u811a\u7f16\u53f7 GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; //\u8bbe\u7f6eGPIO\u7684\u6a21\u5f0f GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; //\u8bbe\u7f6eGPIO\u7684\u901f\u5ea6 GPIO_InitStructure.Pull = GPIO_NOPULL; //\u8bbe\u7f6eGPIO\u7684\u4e0a\u4e0b\u62c9\u72b6\u6001 HAL_GPIO_Init(GPIOD, &GPIO_InitStructure); //GPIO\u7684\u521d\u59cb\u5316\uff0c\u4e00\u6837\u9700\u8981\u6539\u8981\u4f7f\u80fd\u7684GPIO\u7684\u7ec4\u522b for (;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); //\u8c03\u7528\u5e93\u51fd\u6570\u66f4\u6539\u4f7f\u80fd\u7684GPIO\u53e3\u7684\u72b6\u6001\uff0c\u5165\u53e3\u53c2\u6570\u7684\u7ec4\u522b\u4e0e\u5f15\u811a\u7f16\u53f7\u5747\u9700\u8981\u6539\u53d8 HAL_Delay(500); //\u8c03\u7528HAL delay\u5e93\u51fd\u6570\uff0c\u5ef6\u8fdf\u4e00\u5b9a\u65f6\u95f4\uff0c\u5355\u4f4dms HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET); //\u540c\u4e0a HAL_Delay(500); } }","title":"Getting Started"},{"location":"Getting-Started/#led","text":"#\u9996\u5148\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5de5\u7a0b\u6587\u6863\uff0c\u7136\u540e\u5c06\u4f1a\u5f97\u5230\u4e00\u4e0b\u5de5\u7a0b\u6a21\u677f #include \"stm32f4xx_hal.h\" #include \"can.h\" #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } //\u4ee5\u4e0a\u4e3a\u5934\u6587\u4ef6\u52a0\u8f7d\u4e0e\u7cfb\u7edf\u8ba1\u65f6\u5668\u3001\u4e2d\u65ad\u670d\u52a1\u51fd\u6570\u521d\u59cb\u5316 int main(void) //\u4e3b\u51fd\u6570\uff0c\u70b9\u4eaeLED\u706f\u7684\u91cd\u70b9 { HAL_Init(); //HAL\u5e93\u51fd\u6570\u7684\u521d\u59cb\u5316 __GPIOD_CLK_ENABLE(); //\u521d\u59cb\u5316GPIO\u5bf9\u5e94\u7ec4\u7684\u65f6\u949f\uff0c\u9700\u8981\u67e5\u770b\u539f\u7406\u56fe\u627e\u5230\u60f3\u8981\u4f7f\u80fd\u7684GPIO\u53e3\u7684\u7ec4\u522b\uff08\u7ec4\u522b\u4eceA-G\uff09 GPIO_InitTypeDef GPIO_InitStructure; //\u5b9a\u4e49\u4e00\u4e2aGPIO\u521d\u59cb\u5316\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u914d\u7f6e\u76f8\u5173\u5bc4\u5b58\u5668 GPIO_InitStructure.Pin = GPIO_PIN_12; //pin\u811a\u7684\u8bbe\u7f6e\uff0c\u9700\u8981\u67e5\u770b\u539f\u7406\u56fe\u5f97\u5230\u5bf9\u5e94pin\u811a\u7f16\u53f7 GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; //\u8bbe\u7f6eGPIO\u7684\u6a21\u5f0f GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; //\u8bbe\u7f6eGPIO\u7684\u901f\u5ea6 GPIO_InitStructure.Pull = GPIO_NOPULL; //\u8bbe\u7f6eGPIO\u7684\u4e0a\u4e0b\u62c9\u72b6\u6001 HAL_GPIO_Init(GPIOD, &GPIO_InitStructure); //GPIO\u7684\u521d\u59cb\u5316\uff0c\u4e00\u6837\u9700\u8981\u6539\u8981\u4f7f\u80fd\u7684GPIO\u7684\u7ec4\u522b for (;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); //\u8c03\u7528\u5e93\u51fd\u6570\u66f4\u6539\u4f7f\u80fd\u7684GPIO\u53e3\u7684\u72b6\u6001\uff0c\u5165\u53e3\u53c2\u6570\u7684\u7ec4\u522b\u4e0e\u5f15\u811a\u7f16\u53f7\u5747\u9700\u8981\u6539\u53d8 HAL_Delay(500); //\u8c03\u7528HAL delay\u5e93\u51fd\u6570\uff0c\u5ef6\u8fdf\u4e00\u5b9a\u65f6\u95f4\uff0c\u5355\u4f4dms HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET); //\u540c\u4e0a HAL_Delay(500); } }","title":"\u57fa\u7840\u5165\u95e8 \u70b9\u4eae\u7b2c\u4e00\u76cfled\u706f"},{"location":"Hardware-Support/","text":"\u786c\u4ef6\u652f\u6301 \u8be6\u60c5\u8bf7\u89c1\uff1a \u53a6\u95e8\u5927\u5b66\u00b7RoboMaster\u00b7\u786c\u4ef6\u6807\u51c6\u5316\u6587\u6863","title":"Hardware Support"},{"location":"Hardware-Support/#_1","text":"\u8be6\u60c5\u8bf7\u89c1\uff1a \u53a6\u95e8\u5927\u5b66\u00b7RoboMaster\u00b7\u786c\u4ef6\u6807\u51c6\u5316\u6587\u6863","title":"\u786c\u4ef6\u652f\u6301"},{"location":"How-to-Debug/","text":"\u5982\u4f55\u8c03\u8bd5","title":"How to Debug"},{"location":"How-to-Debug/#_1","text":"","title":"\u5982\u4f55\u8c03\u8bd5"},{"location":"Introduction/","text":"\u8f6f\u4ef6\u6807\u51c6\u5316\u7528\u6237\u624b\u518c","title":"Introduction"},{"location":"Introduction/#_1","text":"","title":"\u8f6f\u4ef6\u6807\u51c6\u5316\u7528\u6237\u624b\u518c"},{"location":"Motor-Control/","text":"\u7535\u673a\u63a7\u5236 \u5728\u673a\u5668\u4eba\u8fd0\u52a8\u4e2d\uff0c\u7535\u673a\u63a7\u5236\u4e3a\u6700\u91cd\u8981\u7684\u90e8\u5206\u4e4b\u4e00\uff0c\u673a\u5668\u4eba\u7684\u5404\u79cd\u8fd0\u52a8\u90fd\u79bb\u4e0d\u5f00\u7535\u673a\u7684\u8fd0\u4f5c\u3002\u5199\u7a0b\u5e8f\u7684\u65f6\u5019\u6700\u5fcc\u8bb3\u91cd\u590d\u9020\u8f6e\u5b50\uff0c\u8fd9\u91cc\u5c31\u4ee5\u5df2\u6709\u7684\u6b65\u5175\u6807\u51c6\u4ee3\u7801\u4e3a\u4f8b\uff0c\u5229\u7528\u5df2\u7ecf\u5b9e\u73b0\u7684\u65b9\u6cd5\u5bf9\u7535\u673a\u8fdb\u884c\u4e00\u4e9b\u63a7\u5236\u3002 \u6211\u4eec\u5e38\u7528\u7684\u7535\u673a\u6709\u4e09\u79cdM3508\u7535\u673a\uff08\u9700\u642d\u914dC6020\u7535\u8c03\u4f7f\u7528\uff09\u3001GM6020\u7535\u673a\u3001M2006\u7535\u673a\uff08\u9700\u642d\u914dC6010\u7535\u8c03\u4f7f\u7528\uff09 \u5934\u6587\u4ef6 \u7535\u673a\u7c7b\u5934\u6587\u4ef6\u4e3a motor.h \uff0c\u91cc\u9762\u6784\u9020\u4e86\u5b9e\u73b0\u4e86\u7535\u673a\u7c7b\u7684\u4e00\u4e9b\u5b9e\u73b0 \u53c2\u6570\u5b9a\u4e49 constexpr auto MAXSPEED = 4000; constexpr auto ADJUSTSPEED = 3000; enum { ID1 = 0x201, ID2, ID3, ID4, ID5, ID6, ID7, ID8}; enum { pre = 0, now }; enum pid_mode{ speed = 0, position }; enum motor_type{ M3508, M3510, M2310, EC60, M6623, M6020 }; //M2310\u4e5f\u662fM2006 enum motor_mode { SPD, POS, ACE }; #define SQRTF(x) ((x)>0?sqrtf(x):-sqrtf(-x)) #define T 1.e-3f \u8be5\u90e8\u5206\u4e3a\u4e00\u4e9b\u6570\u503c\u7684\u9884\u5b9a\u4e49\uff0c\u5305\u62ec\u4e00\u4e9bID\u7684\u503c\u679a\u4e3e\uff0cID\u4ee3\u8868\u7740\u5404\u4e2a\u7535\u673a\u7684\u6807\u8bc6\u7b26\uff0c\u5177\u4f53\u6570\u636e\u89c1 \u7535\u673a\u53c2\u6570 Motor\u7c7b class Motor { /*\u5177\u4f53\u5b9e\u73b0*/ } public\u90e8\u5206\u4e2d\u5b9a\u4e49\u4e86\u7535\u673a\u7684\u6784\u9020\u51fd\u6570\uff0c\u7535\u673a\u63a7\u5236\u65b9\u6cd5\u3001\u4ee5\u53ca\u7535\u673a\u7684\u4e09\u79cd\u64cd\u4f5c\u6a21\u5f0f \u6784\u9020\u51fd\u6570 //\u6784\u9020\u51fd\u65701\uff1a\u9700\u586b\u5165\u4e94\u4e2a\u53c2\u6570; \u7535\u673a\u8fd0\u52a8\u8fc7\u7a0b\u7531\u901f\u5ea6\u73af\u4e0e\u4f4d\u7f6e\u73af\u5171\u540c\u8c03\u8282 //\u4e00\u822c\u5728GM6020\u7535\u673a\u4e0a\u4f7f\u7528\u6b64\u6784\u9020\u51fd\u6570 Motor(const type_t type,const motor_mode mode,const uint32_t id, PID _speed, PID _position) : ID(id) , type(type) , mode(mode) { getmax(type); memcpy(&pid[speed], &_speed, sizeof(PID)); memcpy(&pid[position], &_position, sizeof(PID)); } //\u6784\u9020\u51fd\u65702\uff1a\u9700\u586b\u51654\u4e2a\u53c2\u6570; \u7535\u673a\u8fd0\u52a8\u8fc7\u7a0b\u4ec5\u7531\u901f\u5ea6\u73af\u8c03\u8282 //\u4e00\u822c\u5728M3508\u3001M2006\u7535\u673a\u4e0a\u4f7f\u7528\u6b64 Motor(const type_t type, const motor_mode mode, const uint32_t id, PID _speed) : ID(id) , type(type) , mode(mode) { getmax(type); memcpy(&pid[speed], &_speed, sizeof(PID)); } \u5177\u4f53\u5b9e\u73b0 /* *\u6839\u636e\u7535\u673a\u6a21\u578b\u6765\u5b9e\u73b0\u5176\u529f\u80fd *para1: idata[][8]\u7535\u8c03\u7684\u63a5\u53d7\u62a5\u6587 *para2: odata \u8f93\u51fa\u62a5\u6587 *\u5b9e\u73b0\u529f\u80fd:\u53ef\u4ee5\u6839\u636eC620\u7535\u8c03\u7684\u6536\u53d1\u62a5\u6587\u63a7\u5236\u7535\u673a\u7684\u8fd0\u8f6c */ void Ontimer(uint8_t idata[][8], uint8_t* odata) { const uint32_t ID = this->ID - ID1; angle[now] = getword(idata[ID][0], idata[ID][1]); if(type == EC60)curspeed = static_cast<float>(getdeltaa(angle[now] - angle[pre])) / T / 8192.f * 60.f; else curspeed = getword(idata[ID][2], idata[ID][3]); ///angle[pre]&angle[now]&curspeed are available. if(mode == ACE)//accurate mode { curcircle += getdeltaa(angle[now] - angle[pre]); if (spinning) { const int32_t diff = curcircle - setcircle; if (std::fabs(diff) >= 4096) setspeed = -adjspeed * SQRTF((float)diff / (float)spinning); else { // = std::fabs(diff); setangle = 8192 + ((diff < 0) ? -1 : 1)*(std::abs(diff) % 8192); spinning = 0; } } else { setcircle = curcircle; const float error = getdeltaa(setangle - angle[now]); if (std::fabs(error) < 30.f)setspeed = 0.0; else { setspeed = pid[position].Position(//pid[position].Filter( getdeltaa(setangle - angle[now])); setspeed = setrange(setspeed, maxspeed); } } current += pid[speed].Delta(setspeed - curspeed); current = setrange(current, maxcurrent); } else if(mode == POS)//position mode { const float error = getdeltaa(setangle - angle[now]); //if (fabs(error) < 30.f)setspeed = 0.0; //else { setspeed = pid[position].Position(( getdeltaa(setangle - angle[now]))); setspeed = setrange(setspeed, maxspeed); } current = pid[speed].Position(setspeed - curspeed); current = setrange(current, maxcurrent); } else if(mode == SPD)//speed mode //proceed speed any way. { current += pid[speed].Delta(setspeed - curspeed); current = setrange(current, maxcurrent); } angle[pre] = angle[now]; odata[ID * 2] = (current & 0xff00) >> 8; odata[ID * 2 + 1] = current & 0x00ff; } \u8fd8\u6709\u4e00\u4e9b\u5176\u4ed6\u7684\u529f\u80fd\u51fd\u6570 /* *\u7528\u4e8e\u6839\u636e\u7535\u673a\u578b\u53f7\u8fd4\u56de\u4e0a\u9650\u503c */ void getmax(const type_t type) { adjspeed = 3000; switch(type) { case M3508: case M3510: maxcurrent = 13000; maxspeed = 9000; break; case M2310: maxcurrent = 13000; maxspeed = 9000; break; case EC60: maxcurrent = 5000; maxspeed = 300; break; case M6623: maxcurrent = 5000; maxspeed = 300; break; case M6020: maxcurrent = 30000; maxspeed = 80; adjspeed = 80; break; default:; } }","title":"Motor Control"},{"location":"Motor-Control/#_1","text":"\u7535\u673a\u7c7b\u5934\u6587\u4ef6\u4e3a motor.h \uff0c\u91cc\u9762\u6784\u9020\u4e86\u5b9e\u73b0\u4e86\u7535\u673a\u7c7b\u7684\u4e00\u4e9b\u5b9e\u73b0","title":"\u5934\u6587\u4ef6"},{"location":"Motor-Control/#_2","text":"constexpr auto MAXSPEED = 4000; constexpr auto ADJUSTSPEED = 3000; enum { ID1 = 0x201, ID2, ID3, ID4, ID5, ID6, ID7, ID8}; enum { pre = 0, now }; enum pid_mode{ speed = 0, position }; enum motor_type{ M3508, M3510, M2310, EC60, M6623, M6020 }; //M2310\u4e5f\u662fM2006 enum motor_mode { SPD, POS, ACE }; #define SQRTF(x) ((x)>0?sqrtf(x):-sqrtf(-x)) #define T 1.e-3f \u8be5\u90e8\u5206\u4e3a\u4e00\u4e9b\u6570\u503c\u7684\u9884\u5b9a\u4e49\uff0c\u5305\u62ec\u4e00\u4e9bID\u7684\u503c\u679a\u4e3e\uff0cID\u4ee3\u8868\u7740\u5404\u4e2a\u7535\u673a\u7684\u6807\u8bc6\u7b26\uff0c\u5177\u4f53\u6570\u636e\u89c1 \u7535\u673a\u53c2\u6570","title":"\u53c2\u6570\u5b9a\u4e49"},{"location":"Motor-Control/#motor","text":"class Motor { /*\u5177\u4f53\u5b9e\u73b0*/ } public\u90e8\u5206\u4e2d\u5b9a\u4e49\u4e86\u7535\u673a\u7684\u6784\u9020\u51fd\u6570\uff0c\u7535\u673a\u63a7\u5236\u65b9\u6cd5\u3001\u4ee5\u53ca\u7535\u673a\u7684\u4e09\u79cd\u64cd\u4f5c\u6a21\u5f0f","title":"Motor\u7c7b"},{"location":"Motor-Control/#_3","text":"//\u6784\u9020\u51fd\u65701\uff1a\u9700\u586b\u5165\u4e94\u4e2a\u53c2\u6570; \u7535\u673a\u8fd0\u52a8\u8fc7\u7a0b\u7531\u901f\u5ea6\u73af\u4e0e\u4f4d\u7f6e\u73af\u5171\u540c\u8c03\u8282 //\u4e00\u822c\u5728GM6020\u7535\u673a\u4e0a\u4f7f\u7528\u6b64\u6784\u9020\u51fd\u6570 Motor(const type_t type,const motor_mode mode,const uint32_t id, PID _speed, PID _position) : ID(id) , type(type) , mode(mode) { getmax(type); memcpy(&pid[speed], &_speed, sizeof(PID)); memcpy(&pid[position], &_position, sizeof(PID)); } //\u6784\u9020\u51fd\u65702\uff1a\u9700\u586b\u51654\u4e2a\u53c2\u6570; \u7535\u673a\u8fd0\u52a8\u8fc7\u7a0b\u4ec5\u7531\u901f\u5ea6\u73af\u8c03\u8282 //\u4e00\u822c\u5728M3508\u3001M2006\u7535\u673a\u4e0a\u4f7f\u7528\u6b64 Motor(const type_t type, const motor_mode mode, const uint32_t id, PID _speed) : ID(id) , type(type) , mode(mode) { getmax(type); memcpy(&pid[speed], &_speed, sizeof(PID)); }","title":"\u6784\u9020\u51fd\u6570"},{"location":"Motor-Control/#_4","text":"/* *\u6839\u636e\u7535\u673a\u6a21\u578b\u6765\u5b9e\u73b0\u5176\u529f\u80fd *para1: idata[][8]\u7535\u8c03\u7684\u63a5\u53d7\u62a5\u6587 *para2: odata \u8f93\u51fa\u62a5\u6587 *\u5b9e\u73b0\u529f\u80fd:\u53ef\u4ee5\u6839\u636eC620\u7535\u8c03\u7684\u6536\u53d1\u62a5\u6587\u63a7\u5236\u7535\u673a\u7684\u8fd0\u8f6c */ void Ontimer(uint8_t idata[][8], uint8_t* odata) { const uint32_t ID = this->ID - ID1; angle[now] = getword(idata[ID][0], idata[ID][1]); if(type == EC60)curspeed = static_cast<float>(getdeltaa(angle[now] - angle[pre])) / T / 8192.f * 60.f; else curspeed = getword(idata[ID][2], idata[ID][3]); ///angle[pre]&angle[now]&curspeed are available. if(mode == ACE)//accurate mode { curcircle += getdeltaa(angle[now] - angle[pre]); if (spinning) { const int32_t diff = curcircle - setcircle; if (std::fabs(diff) >= 4096) setspeed = -adjspeed * SQRTF((float)diff / (float)spinning); else { // = std::fabs(diff); setangle = 8192 + ((diff < 0) ? -1 : 1)*(std::abs(diff) % 8192); spinning = 0; } } else { setcircle = curcircle; const float error = getdeltaa(setangle - angle[now]); if (std::fabs(error) < 30.f)setspeed = 0.0; else { setspeed = pid[position].Position(//pid[position].Filter( getdeltaa(setangle - angle[now])); setspeed = setrange(setspeed, maxspeed); } } current += pid[speed].Delta(setspeed - curspeed); current = setrange(current, maxcurrent); } else if(mode == POS)//position mode { const float error = getdeltaa(setangle - angle[now]); //if (fabs(error) < 30.f)setspeed = 0.0; //else { setspeed = pid[position].Position(( getdeltaa(setangle - angle[now]))); setspeed = setrange(setspeed, maxspeed); } current = pid[speed].Position(setspeed - curspeed); current = setrange(current, maxcurrent); } else if(mode == SPD)//speed mode //proceed speed any way. { current += pid[speed].Delta(setspeed - curspeed); current = setrange(current, maxcurrent); } angle[pre] = angle[now]; odata[ID * 2] = (current & 0xff00) >> 8; odata[ID * 2 + 1] = current & 0x00ff; } \u8fd8\u6709\u4e00\u4e9b\u5176\u4ed6\u7684\u529f\u80fd\u51fd\u6570 /* *\u7528\u4e8e\u6839\u636e\u7535\u673a\u578b\u53f7\u8fd4\u56de\u4e0a\u9650\u503c */ void getmax(const type_t type) { adjspeed = 3000; switch(type) { case M3508: case M3510: maxcurrent = 13000; maxspeed = 9000; break; case M2310: maxcurrent = 13000; maxspeed = 9000; break; case EC60: maxcurrent = 5000; maxspeed = 300; break; case M6623: maxcurrent = 5000; maxspeed = 300; break; case M6020: maxcurrent = 30000; maxspeed = 80; adjspeed = 80; break; default:; } }","title":"\u5177\u4f53\u5b9e\u73b0"},{"location":"Motor-Parameters/","text":"C620\u7535\u8c03 CAN\u901a\u8baf\u534f\u8bae \u7535\u8c03\u63a5\u53d7\u62a5\u6587 \u4e24\u4e2a\u6807\u8bc6\u7b26\uff080x200 0x1FF\uff09\u5404\u81ea\u5bf9\u5e94\u63a7\u52364\u4e2aID\u7684\u7535\u8c03 \u63a7\u5236\u7535\u6d41\u503c\u8303\u56f4 -16384 ~ 0 ~ 16384 \u8f6c\u77e9\u7535\u6d41-20 ~ 0 ~ 20A \u7535\u8c03\u53cd\u9988\u62a5\u6587 GM6020\u7535\u673a \u7535\u673a\u63a5\u53d7\u62a5\u6587 \u7535\u673a\u53cd\u9988\u62a5\u6587","title":"Motor Parameters"},{"location":"Motor-Parameters/#c620","text":"CAN\u901a\u8baf\u534f\u8bae","title":"C620\u7535\u8c03"},{"location":"Motor-Parameters/#_1","text":"\u4e24\u4e2a\u6807\u8bc6\u7b26\uff080x200 0x1FF\uff09\u5404\u81ea\u5bf9\u5e94\u63a7\u52364\u4e2aID\u7684\u7535\u8c03 \u63a7\u5236\u7535\u6d41\u503c\u8303\u56f4 -16384 ~ 0 ~ 16384 \u8f6c\u77e9\u7535\u6d41-20 ~ 0 ~ 20A","title":"\u7535\u8c03\u63a5\u53d7\u62a5\u6587"},{"location":"Motor-Parameters/#_2","text":"","title":"\u7535\u8c03\u53cd\u9988\u62a5\u6587"},{"location":"Motor-Parameters/#gm6020","text":"","title":"GM6020\u7535\u673a"},{"location":"Motor-Parameters/#_3","text":"","title":"\u7535\u673a\u63a5\u53d7\u62a5\u6587"},{"location":"Motor-Parameters/#_4","text":"","title":"\u7535\u673a\u53cd\u9988\u62a5\u6587"},{"location":"Software-Install/","text":"\u5b89\u88c5Visual GDB for visual studio 2019 \u4e0b\u8f7d\u5b89\u88c5Visual Studio 2019\uff08\u5982\u679c\u5df2\u5b89\u88c5\u8bf7\u8df3\u8fc7\uff09 \u8fdb\u5165 Visual Studio\u5b98\u65b9\u7f51\u7ad9 \u8fdb\u884c\u4e0b\u8f7d\uff0c\u9009\u62e9\u5408\u9002\u7684\u5b89\u88c5\u8def\u5f84( \u8def\u5f84\u4e2d\u786e\u4fdd\u4e0d\u80fd\u6709\u4e2d\u6587 ) \u5b89\u88c5Visual Studio 2019 Comunity\u7248\u672c() \u4e0b\u8f7d\u6211\u4eec\u6240\u9700\u7684C++\u7ec4\u4ef6 \u7b49\u5f85\u5b89\u88c5\u6210\u529f\u3002\u3002\u3002 \u4e0b\u8f7d\u5b89\u88c5VisualGDB \u5173\u95edVisual Studio\uff0c\u53cc\u51fb\u8fd0\u884cVisualGDB-5.5r4.msi \u76f4\u63a5\u9009\u62e9Quick Installation\uff0c\u5982\u679c\u9009\u62e9Common Installation\u4e5f\u53ef\uff0c\u4f46\u9700\u6ce8\u610f\u4e0d\u8981\u6709\u4e2d\u6587\u8def\u5f84 \u5b89\u88c5\u7ed3\u675f\u540e\u8fdb\u5165Visual Studio 2019\uff0c\u70b9\u51fb\u5e2e\u52a9\u4e2dAbout VisualGDB\uff0c\u53ef\u4ee5\u53d1\u73b0GDB\u5df2\u7ecf\u7834\u89e3\u6210\u529f\uff08 \u6ce8\u610f\u5343\u4e07\u4e0d\u8981\u66f4\u65b0\uff0c\u66f4\u65b0\u4e4b\u540e\u5c31\u65e0\u6cd5\u7834\u89e3\uff0c\u9700\u8981\u5378\u8f7dGDB\u540e\u91cd\u65b0\u5b89\u88c5 \uff09 \u9996\u6b21\u542f\u52a8\u65f6\uff0c\u8bf7\u6253\u5f00\u5df2\u6709\u9879\u76ee\u3002\u5982\u679c\u9700\u8981\u91cd\u65b0\u521b\u5efa\u65b0\u9879\u76ee\uff0c\u9700\u8981\u6307\u5b9a\u5de5\u5177\u94fe\u7248\u672c\u4ee5\u53caBSP\uff08Board Support Package\uff09\uff0c\u5b9e\u9645\u4e0a\u5982\u679c\u9700\u8981\u6307\u5b9a\u7684\u7248\u672c\u5f53\u7136\u53ef\u4ee5\uff0c\u4f46\u4e3a\u4e86\u517c\u5bb9\u65e7\u4ee3\u7801\uff0c\u8fd9\u91cc\u76f4\u63a5\u6253\u5f00\u5df2\u6709\u9879\u76ee\uff0cVisual GDB\u4f1a\u81ea\u52a8\u4e0b\u8f7d\u914d\u5957\u7684\u5de5\u5177\u94fe\uff1a \u70b9\u51fbOK\u5f00\u59cb\u4e0b\u8f7d \u4e0a\u8ff0\u4e0b\u8f7d\u53ef\u80fd\u6bd4\u8f83\u6162\uff0c\u5982\u6709\u9700\u8981\u53ef\u4ee5\u5f00\u542f\u5168\u5c40\u4ee3\u7406\uff0c\u8fd9\u91cc\u4e0d\u8fc7\u591a\u8d58\u8ff0\u3002 \u4e4b\u540e\u4e0b\u8f7dBSP\uff0c\u8fd9\u4e5f\u4f1a\u81ea\u52a8\u5339\u914d\u5230stm32\uff0c\u7248\u672c\u4e3a3.6\u3002\u70b9\u51fbDownload BSP\u5373\u53ef \u91cd\u65b0\u751f\u6210MSBuild\u6587\u4ef6\uff0c\u70b9\u51fbYes\u5373\u53ef \u6b64\u65f6\u5373\u53ef\u67e5\u770b\u8be5\u5de5\u7a0b\uff0c\u6309Ctrl+Shift+B\u542f\u52a8Build\uff0c\u7a0d\u7b49\u540e\u663e\u793a\u9879\u76ee\u751f\u6210\u6210\u529f\u5373\u53ef\u3002 \u8f93\u51fa\u4e2d\u4e5f\u8bb8\u4f1a\u6709\u7ea2\u8272\u7684warning\uff0c\u4e0d\u7528\u7406\u4f1a\u3002\u53ea\u8981\u80fd\u751f\u6210\u6210\u529f\u5c31\u884c\u3002\u4e5f\u53ef\u80fd\u4f1a\u63d0\u793a\u4e00\u4e9b\u6587\u4ef6\u7f3a\u5931\uff0c\u6709\u53ef\u80fd\u662f\u9879\u76ee\u6587\u4ef6\u672c\u8eab\u7684\u95ee\u9898 \u914d\u7f6e\u8c03\u8bd5\u5668\uff0c\u5728\u89e3\u51b3\u65b9\u6848\u8d44\u6e90\u7ba1\u7406\u5668\u4e2d\uff0c\u53f3\u952e\u70b9\u51fb\u9879\u76ee\u540d\uff0c\u9009\u62e9VisualGDB Project Properties. \u67e5\u770bDebug settings\uff0c\u9009\u62e9OpenOCD\u5e76\u4e0b\u8f7d\u3002 \u4e0b\u8f7d\u5b8c\u6bd5\u540e\uff0c\u5728SWD programmer\u5185\u9009\u62e9ST-Link v2\uff1a\uff08v2\u8fd8\u662f\u5176\u5b83\u9700\u89c6\u60c5\u51b5\u800c\u5b9a\uff09 \u70b9\u51fbDebug using\u540e\u9762\u7684Test\uff0c\u5982\u679c\u770b\u5230\u5982\u4e0b\u63d0\u793a\uff0c\u8bf4\u660e\u4e00\u5207\u6b63\u5e38\u3002 \u56de\u5230\u9879\u76ee\u4e2d\uff0c\u6309Ctrl+F5\u5373\u53ef\u70e7\u5f55\u7a0b\u5e8f\u3002 \u82e5\u6309\u4e0a\u8ff0\u64cd\u4f5c\u65e0\u679c\uff0c\u9700\u8981\u624b\u52a8\u9009\u62e9STN32 Devices \u4e0b\u8f7d\u3002 VisualGDB\u7684\u4f18\u70b9 VisualGDB\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u8c03\u8bd5\u529f\u80fd\uff0c\u5e76\u4e14\u53ef\u4ee5\u5229\u7528Visual Studio\u539f\u672c\u7684Intellisense\u7b49\u4ee3\u7801\u7f16\u8f91\u5de5\u5177\uff0c\u6700\u6709\u4ef7\u503c\u7684\u662f\u4f7f\u7528Live Variables\u5b9e\u65f6\u89c2\u5bdf\u53d8\u91cf\uff0c\u5e76\u4e14\u53ef\u4ee5\u89c2\u5bdf\u6570\u636e\u66f2\u7ebf\uff1a \u200b \u53e6\u5916\u4e00\u4e2a\u662f\u8c03\u7528\u5806\u6808\u3002\u5f53\u7a0b\u5e8f\u8fdb\u5165\u9519\u8bef\u4e2d\u65ad\u65f6\u6700\u6709\u7528\uff0c\u901a\u8fc7\u89c2\u5bdf\u5806\u6808\u4fe1\u606f\u5373\u53ef\u627e\u5230\u76f4\u63a5\u5bfc\u81f4\u9519\u8bef\u7684\u4f4d\u7f6e\uff0c\u8fd9\u662f\u76ee\u524dKeil\u65e0\u6cd5\u53d6\u4ee3\u7684\u529f\u80fd\u3002 \u795d\u5927\u5bb6\u64cd\u4f5c\u987a\u5229\uff01 \u5982\u679c\u5b89\u88c5\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u5176\u4ed6\u95ee\u9898\uff0c\u8bf7\u81ea\u884c\u8fdb\u884c\u4e0a\u7f51\u641c\u7d22\uff0c\u89e3\u51b3\u65b9\u6848\u9700\u8981\u4e00\u70b9\u70b9\u6478\u7d22\u51fa\u6765\uff01\u987a\u4fbf\u5199\u8fdb\u6211\u4eecRCS\u7ecf\u9a8c\u5e93\u4e2d","title":"Software Install"},{"location":"Software-Install/#visual-studio-2019","text":"\u8fdb\u5165 Visual Studio\u5b98\u65b9\u7f51\u7ad9 \u8fdb\u884c\u4e0b\u8f7d\uff0c\u9009\u62e9\u5408\u9002\u7684\u5b89\u88c5\u8def\u5f84( \u8def\u5f84\u4e2d\u786e\u4fdd\u4e0d\u80fd\u6709\u4e2d\u6587 ) \u5b89\u88c5Visual Studio 2019 Comunity\u7248\u672c() \u4e0b\u8f7d\u6211\u4eec\u6240\u9700\u7684C++\u7ec4\u4ef6 \u7b49\u5f85\u5b89\u88c5\u6210\u529f\u3002\u3002\u3002","title":"\u4e0b\u8f7d\u5b89\u88c5Visual Studio 2019\uff08\u5982\u679c\u5df2\u5b89\u88c5\u8bf7\u8df3\u8fc7\uff09"},{"location":"Software-Install/#visualgdb","text":"\u5173\u95edVisual Studio\uff0c\u53cc\u51fb\u8fd0\u884cVisualGDB-5.5r4.msi \u76f4\u63a5\u9009\u62e9Quick Installation\uff0c\u5982\u679c\u9009\u62e9Common Installation\u4e5f\u53ef\uff0c\u4f46\u9700\u6ce8\u610f\u4e0d\u8981\u6709\u4e2d\u6587\u8def\u5f84 \u5b89\u88c5\u7ed3\u675f\u540e\u8fdb\u5165Visual Studio 2019\uff0c\u70b9\u51fb\u5e2e\u52a9\u4e2dAbout VisualGDB\uff0c\u53ef\u4ee5\u53d1\u73b0GDB\u5df2\u7ecf\u7834\u89e3\u6210\u529f\uff08 \u6ce8\u610f\u5343\u4e07\u4e0d\u8981\u66f4\u65b0\uff0c\u66f4\u65b0\u4e4b\u540e\u5c31\u65e0\u6cd5\u7834\u89e3\uff0c\u9700\u8981\u5378\u8f7dGDB\u540e\u91cd\u65b0\u5b89\u88c5 \uff09 \u9996\u6b21\u542f\u52a8\u65f6\uff0c\u8bf7\u6253\u5f00\u5df2\u6709\u9879\u76ee\u3002\u5982\u679c\u9700\u8981\u91cd\u65b0\u521b\u5efa\u65b0\u9879\u76ee\uff0c\u9700\u8981\u6307\u5b9a\u5de5\u5177\u94fe\u7248\u672c\u4ee5\u53caBSP\uff08Board Support Package\uff09\uff0c\u5b9e\u9645\u4e0a\u5982\u679c\u9700\u8981\u6307\u5b9a\u7684\u7248\u672c\u5f53\u7136\u53ef\u4ee5\uff0c\u4f46\u4e3a\u4e86\u517c\u5bb9\u65e7\u4ee3\u7801\uff0c\u8fd9\u91cc\u76f4\u63a5\u6253\u5f00\u5df2\u6709\u9879\u76ee\uff0cVisual GDB\u4f1a\u81ea\u52a8\u4e0b\u8f7d\u914d\u5957\u7684\u5de5\u5177\u94fe\uff1a \u70b9\u51fbOK\u5f00\u59cb\u4e0b\u8f7d \u4e0a\u8ff0\u4e0b\u8f7d\u53ef\u80fd\u6bd4\u8f83\u6162\uff0c\u5982\u6709\u9700\u8981\u53ef\u4ee5\u5f00\u542f\u5168\u5c40\u4ee3\u7406\uff0c\u8fd9\u91cc\u4e0d\u8fc7\u591a\u8d58\u8ff0\u3002 \u4e4b\u540e\u4e0b\u8f7dBSP\uff0c\u8fd9\u4e5f\u4f1a\u81ea\u52a8\u5339\u914d\u5230stm32\uff0c\u7248\u672c\u4e3a3.6\u3002\u70b9\u51fbDownload BSP\u5373\u53ef \u91cd\u65b0\u751f\u6210MSBuild\u6587\u4ef6\uff0c\u70b9\u51fbYes\u5373\u53ef \u6b64\u65f6\u5373\u53ef\u67e5\u770b\u8be5\u5de5\u7a0b\uff0c\u6309Ctrl+Shift+B\u542f\u52a8Build\uff0c\u7a0d\u7b49\u540e\u663e\u793a\u9879\u76ee\u751f\u6210\u6210\u529f\u5373\u53ef\u3002 \u8f93\u51fa\u4e2d\u4e5f\u8bb8\u4f1a\u6709\u7ea2\u8272\u7684warning\uff0c\u4e0d\u7528\u7406\u4f1a\u3002\u53ea\u8981\u80fd\u751f\u6210\u6210\u529f\u5c31\u884c\u3002\u4e5f\u53ef\u80fd\u4f1a\u63d0\u793a\u4e00\u4e9b\u6587\u4ef6\u7f3a\u5931\uff0c\u6709\u53ef\u80fd\u662f\u9879\u76ee\u6587\u4ef6\u672c\u8eab\u7684\u95ee\u9898 \u914d\u7f6e\u8c03\u8bd5\u5668\uff0c\u5728\u89e3\u51b3\u65b9\u6848\u8d44\u6e90\u7ba1\u7406\u5668\u4e2d\uff0c\u53f3\u952e\u70b9\u51fb\u9879\u76ee\u540d\uff0c\u9009\u62e9VisualGDB Project Properties. \u67e5\u770bDebug settings\uff0c\u9009\u62e9OpenOCD\u5e76\u4e0b\u8f7d\u3002 \u4e0b\u8f7d\u5b8c\u6bd5\u540e\uff0c\u5728SWD programmer\u5185\u9009\u62e9ST-Link v2\uff1a\uff08v2\u8fd8\u662f\u5176\u5b83\u9700\u89c6\u60c5\u51b5\u800c\u5b9a\uff09 \u70b9\u51fbDebug using\u540e\u9762\u7684Test\uff0c\u5982\u679c\u770b\u5230\u5982\u4e0b\u63d0\u793a\uff0c\u8bf4\u660e\u4e00\u5207\u6b63\u5e38\u3002 \u56de\u5230\u9879\u76ee\u4e2d\uff0c\u6309Ctrl+F5\u5373\u53ef\u70e7\u5f55\u7a0b\u5e8f\u3002 \u82e5\u6309\u4e0a\u8ff0\u64cd\u4f5c\u65e0\u679c\uff0c\u9700\u8981\u624b\u52a8\u9009\u62e9STN32 Devices \u4e0b\u8f7d\u3002","title":"\u4e0b\u8f7d\u5b89\u88c5VisualGDB"},{"location":"Software-Install/#visualgdb_1","text":"VisualGDB\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u8c03\u8bd5\u529f\u80fd\uff0c\u5e76\u4e14\u53ef\u4ee5\u5229\u7528Visual Studio\u539f\u672c\u7684Intellisense\u7b49\u4ee3\u7801\u7f16\u8f91\u5de5\u5177\uff0c\u6700\u6709\u4ef7\u503c\u7684\u662f\u4f7f\u7528Live Variables\u5b9e\u65f6\u89c2\u5bdf\u53d8\u91cf\uff0c\u5e76\u4e14\u53ef\u4ee5\u89c2\u5bdf\u6570\u636e\u66f2\u7ebf\uff1a \u200b \u53e6\u5916\u4e00\u4e2a\u662f\u8c03\u7528\u5806\u6808\u3002\u5f53\u7a0b\u5e8f\u8fdb\u5165\u9519\u8bef\u4e2d\u65ad\u65f6\u6700\u6709\u7528\uff0c\u901a\u8fc7\u89c2\u5bdf\u5806\u6808\u4fe1\u606f\u5373\u53ef\u627e\u5230\u76f4\u63a5\u5bfc\u81f4\u9519\u8bef\u7684\u4f4d\u7f6e\uff0c\u8fd9\u662f\u76ee\u524dKeil\u65e0\u6cd5\u53d6\u4ee3\u7684\u529f\u80fd\u3002 \u795d\u5927\u5bb6\u64cd\u4f5c\u987a\u5229\uff01 \u5982\u679c\u5b89\u88c5\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u5176\u4ed6\u95ee\u9898\uff0c\u8bf7\u81ea\u884c\u8fdb\u884c\u4e0a\u7f51\u641c\u7d22\uff0c\u89e3\u51b3\u65b9\u6848\u9700\u8981\u4e00\u70b9\u70b9\u6478\u7d22\u51fa\u6765\uff01\u987a\u4fbf\u5199\u8fdb\u6211\u4eecRCS\u7ecf\u9a8c\u5e93\u4e2d","title":"VisualGDB\u7684\u4f18\u70b9"},{"location":"TIM-Use/","text":"\u5b9a\u65f6\u5668 (Timer) \u6700\u57fa\u672c\u7684\u529f\u80fd\u5c31\u662f\u5b9a\u65f6\u4e86\uff0c\u6bd4\u5982\u5b9a\u65f6\u53d1\u9001 USART \u6570\u636e\u3001\u5b9a\u65f6\u91c7\u96c6 AD \u6570\u636e\u7b49\u7b49\u3002 \u5982\u679c\u628a\u5b9a\u65f6\u5668\u4e0e GPIO \u7ed3\u5408\u8d77\u6765\u4f7f\u7528\u7684\u8bdd\u53ef\u4ee5\u5b9e\u73b0\u975e\u5e38\u4e30\u5bcc\u7684\u529f\u80fd\uff0c\u53ef\u4ee5\u6d4b\u91cf\u8f93\u5165\u4fe1\u53f7\u7684\u8109\u51b2\u5bbd \u5ea6\uff0c\u53ef\u4ee5\u751f\u4ea7\u8f93\u51fa\u6ce2\u5f62\u3002\u5b9a\u65f6\u5668\u751f\u4ea7 PWM \u63a7\u5236\u7535\u673a\u72b6\u6001\u662f\u5de5\u4e1a\u63a7\u5236\u666e\u904d\u65b9\u6cd5\uff0c\u8fd9\u65b9\u9762\u77e5\u8bc6\u975e\u5e38 \u6709\u5fc5\u8981\u6df1\u5165\u4e86\u89e3\u3002 tim.h\u548ctim.cpp\u6587\u4ef6\u7684\u4f7f\u7528 tim.h #pragma once #include \"stm32f4xx_hal.h\" #include \"functional\" #include \"gpio.h\" enum{ BASE, PWM, IC }; class TIM { public: TIM& Init(uint32_t Mode, TIM_TypeDef* TIM, uint32_t frequency); void MspPostInit(reuse r) const; void BaseInit(void); TIM& PWMInit(uint32_t channel, float duty, reuse r); void PWMDuty(uint32_t channel, float duty) const; void ICInit(int32_t channel, uint32_t ICPolarity, reuse r); bool operator==(const TIM_HandleTypeDef *htim) { return (&this->htim) == htim; } TIM_HandleTypeDef htim; uint32_t counter; }; extern TIM tasks, fraction, photogate; tim.cpp #include \"tim.h\" #include \"can.h\" #include \"IMU.h\" #include \"motor.h\" #include \"control.h\" #include \"RC.h\" #include \"LED.h\" #include \"judgement.h\" #include \"powerlimit.h\" TIM_HandleTypeDef *phtim[4]; TIM& TIM::Init(const uint32_t Mode, TIM_TypeDef* TIM, const uint32_t frequency) { const float x = 84000000 / frequency; if (x >= 5000) { htim.Init.Prescaler = x / 5000 - 1u; htim.Init.Period = 5000 - 1u; } else { htim.Init.Prescaler = 84u - 1u; htim.Init.Period = x / 84 - 1u; } htim.Instance = TIM; htim.Init.CounterMode = TIM_COUNTERMODE_UP; htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; switch (Mode) { case BASE:HAL_TIM_Base_Init(&htim); break; case PWM:HAL_TIM_PWM_Init(&htim); break; case IC:HAL_TIM_IC_Init(&htim); break; default:; } if (TIM == TIM2)phtim[1] = &htim; if (TIM == TIM3)phtim[2] = &htim; if (TIM == TIM4)phtim[3] = &htim; return *this; } void TIM::MspPostInit(const reuse r) const { GPIO_InitTypeDef GPIO_InitStruct; GPIO_CLK_ENABLE(r.GPIOx); GPIO_InitStruct.Pin = r.Pin; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = this->htim.Instance == TIM2 ? GPIO_AF1_TIM2 : GPIO_AF2_TIM3; HAL_GPIO_Init(r.GPIOx, &GPIO_InitStruct); } extern \"C\" void TIM2_IRQHandler(void) { if (phtim[1])HAL_TIM_IRQHandler(phtim[1]); } extern \"C\" void TIM3_IRQHandler(void) { if (phtim[2])HAL_TIM_IRQHandler(phtim[2]); } extern \"C\" void TIM4_IRQHandler(void) { if (phtim[3])HAL_TIM_IRQHandler(phtim[3]); } void TIM::BaseInit(void) { TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; HAL_TIM_ConfigClockSource(&htim, &sClockSourceConfig); sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); HAL_TIM_Base_Start_IT(&htim); } void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle) { SET_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ __IO uint32_t tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); HAL_NVIC_SetPriority(static_cast<IRQn_Type>((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE) / 0x400U + 28), 0, 0); HAL_NVIC_EnableIRQ(static_cast<IRQn_Type>((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE) / 0x400U + 28)); } extern \"C\" void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { static uint8_t can1_data[16], can2_data[16]; if (tasks.counter++, tasks == htim) { //\u5728\u8fd9\u91cc\u52a0\u5165\u673a\u5668\u4eba\u9700\u8981\u6267\u884c\u7684\u4efb\u52a1\uff08update\uff09 } if (tasks.counter % 4 == 0) { for (auto &motor : can1_motor)motor.Ontimer(can1.data, can1_data); for (auto &motor : can2_motor)motor.Ontimer(can2.data, can2_data); } //can\u901a\u8baf\u7535\u673a\u8f93\u51fa switch (tasks.counter % 5) { case 0:can1.Transmit(0x200, can1_data); break; case 1:can1.Transmit(0x1ff, can1_data + 8); break; case 2:can1.Transmit(0x200, can1_data); break;//\u6b64\u5904\u662f\u4e3a\u4e86\u589e\u5927\u5e95\u76d8\u8f93\u51fa\u7684\u9891\u7387 case 3:can2.Transmit(0x200, can2_data); break; case 4:can2.Transmit(0x1ff, can2_data + 8); break; default:; } } TIM& TIM::PWMInit(uint32_t channel, float duty, reuse r) { TIM_MasterConfigTypeDef sMasterConfig; TIM_OC_InitTypeDef sConfigOC; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = static_cast<unsigned>(duty * (htim.Init.Period + 1)) - 1u; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; HAL_TIM_PWM_ConfigChannel(&htim, &sConfigOC, channel); this->MspPostInit(r); HAL_TIM_PWM_Start(&htim, channel); return *this; } void TIM::PWMDuty(const uint32_t channel, const float duty) const { *reinterpret_cast<uint32_t*>(reinterpret_cast<uint8_t*>(htim.Instance->CCR1) + (channel - TIM_CHANNEL_1)) = (htim.Init.Period + 1)*duty - 1u; } void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle) { __IO uint32_t tmpreg = 0x00U; SET_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_pwmHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_pwmHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); } void TIM::ICInit(int32_t channel, uint32_t ICPolarity, reuse r) { TIM_MasterConfigTypeDef sMasterConfig; TIM_IC_InitTypeDef sConfigIC; this->MspPostInit(r); sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); sConfigIC.ICPolarity = ICPolarity;//TIM_INPUTCHANNELPOLARITY_RISING; sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI; sConfigIC.ICPrescaler = TIM_ICPSC_DIV1; sConfigIC.ICFilter = 0; HAL_TIM_IC_ConfigChannel(&htim, &sConfigIC, channel); HAL_TIM_IC_Start_IT(&htim, channel); } void HAL_TIM_IC_MspInit(TIM_HandleTypeDef* tim_icHandle) { SET_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ __IO uint32_t tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); HAL_NVIC_SetPriority(static_cast<IRQn_Type>(reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE) / 0x400U + 28), 0, 0); HAL_NVIC_EnableIRQ(static_cast<IRQn_Type>(reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE) / 0x400U + 28)); } extern \"C\" void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM4) { if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) { //HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_1); if (!(photogate.counter++ & 1)) ; TIM_MasterConfigTypeDef sMasterConfig; TIM_IC_InitTypeDef sConfigIC; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(htim, &sMasterConfig); sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING; sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI; sConfigIC.ICPrescaler = TIM_ICPSC_DIV1; sConfigIC.ICFilter = 0; HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, htim->Channel); HAL_TIM_IC_Start_IT(htim, htim->Channel); } } } \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecTIM\u5b9a\u65f6\u5668\u7684\u4f7f\u7528\u548c\u8bbe\u7f6e\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528\u5b9a\u65f6\u5668\u529f\u80fd\u6765\u8fdb\u884c\u673a\u5668\u4eba\u590d\u6742\u529f\u80fd\u4ee3\u7801\u7684\u7f16\u5199\u3002","title":"TIM"},{"location":"TIM-Use/#timhtimcpp","text":"","title":"tim.h\u548ctim.cpp\u6587\u4ef6\u7684\u4f7f\u7528"},{"location":"TIM-Use/#timh","text":"#pragma once #include \"stm32f4xx_hal.h\" #include \"functional\" #include \"gpio.h\" enum{ BASE, PWM, IC }; class TIM { public: TIM& Init(uint32_t Mode, TIM_TypeDef* TIM, uint32_t frequency); void MspPostInit(reuse r) const; void BaseInit(void); TIM& PWMInit(uint32_t channel, float duty, reuse r); void PWMDuty(uint32_t channel, float duty) const; void ICInit(int32_t channel, uint32_t ICPolarity, reuse r); bool operator==(const TIM_HandleTypeDef *htim) { return (&this->htim) == htim; } TIM_HandleTypeDef htim; uint32_t counter; }; extern TIM tasks, fraction, photogate;","title":"tim.h"},{"location":"TIM-Use/#timcpp","text":"#include \"tim.h\" #include \"can.h\" #include \"IMU.h\" #include \"motor.h\" #include \"control.h\" #include \"RC.h\" #include \"LED.h\" #include \"judgement.h\" #include \"powerlimit.h\" TIM_HandleTypeDef *phtim[4]; TIM& TIM::Init(const uint32_t Mode, TIM_TypeDef* TIM, const uint32_t frequency) { const float x = 84000000 / frequency; if (x >= 5000) { htim.Init.Prescaler = x / 5000 - 1u; htim.Init.Period = 5000 - 1u; } else { htim.Init.Prescaler = 84u - 1u; htim.Init.Period = x / 84 - 1u; } htim.Instance = TIM; htim.Init.CounterMode = TIM_COUNTERMODE_UP; htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; switch (Mode) { case BASE:HAL_TIM_Base_Init(&htim); break; case PWM:HAL_TIM_PWM_Init(&htim); break; case IC:HAL_TIM_IC_Init(&htim); break; default:; } if (TIM == TIM2)phtim[1] = &htim; if (TIM == TIM3)phtim[2] = &htim; if (TIM == TIM4)phtim[3] = &htim; return *this; } void TIM::MspPostInit(const reuse r) const { GPIO_InitTypeDef GPIO_InitStruct; GPIO_CLK_ENABLE(r.GPIOx); GPIO_InitStruct.Pin = r.Pin; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = this->htim.Instance == TIM2 ? GPIO_AF1_TIM2 : GPIO_AF2_TIM3; HAL_GPIO_Init(r.GPIOx, &GPIO_InitStruct); } extern \"C\" void TIM2_IRQHandler(void) { if (phtim[1])HAL_TIM_IRQHandler(phtim[1]); } extern \"C\" void TIM3_IRQHandler(void) { if (phtim[2])HAL_TIM_IRQHandler(phtim[2]); } extern \"C\" void TIM4_IRQHandler(void) { if (phtim[3])HAL_TIM_IRQHandler(phtim[3]); } void TIM::BaseInit(void) { TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; HAL_TIM_ConfigClockSource(&htim, &sClockSourceConfig); sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); HAL_TIM_Base_Start_IT(&htim); } void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle) { SET_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ __IO uint32_t tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); HAL_NVIC_SetPriority(static_cast<IRQn_Type>((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE) / 0x400U + 28), 0, 0); HAL_NVIC_EnableIRQ(static_cast<IRQn_Type>((reinterpret_cast<unsigned>(tim_baseHandle->Instance) - APB1PERIPH_BASE) / 0x400U + 28)); } extern \"C\" void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { static uint8_t can1_data[16], can2_data[16]; if (tasks.counter++, tasks == htim) { //\u5728\u8fd9\u91cc\u52a0\u5165\u673a\u5668\u4eba\u9700\u8981\u6267\u884c\u7684\u4efb\u52a1\uff08update\uff09 } if (tasks.counter % 4 == 0) { for (auto &motor : can1_motor)motor.Ontimer(can1.data, can1_data); for (auto &motor : can2_motor)motor.Ontimer(can2.data, can2_data); } //can\u901a\u8baf\u7535\u673a\u8f93\u51fa switch (tasks.counter % 5) { case 0:can1.Transmit(0x200, can1_data); break; case 1:can1.Transmit(0x1ff, can1_data + 8); break; case 2:can1.Transmit(0x200, can1_data); break;//\u6b64\u5904\u662f\u4e3a\u4e86\u589e\u5927\u5e95\u76d8\u8f93\u51fa\u7684\u9891\u7387 case 3:can2.Transmit(0x200, can2_data); break; case 4:can2.Transmit(0x1ff, can2_data + 8); break; default:; } } TIM& TIM::PWMInit(uint32_t channel, float duty, reuse r) { TIM_MasterConfigTypeDef sMasterConfig; TIM_OC_InitTypeDef sConfigOC; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = static_cast<unsigned>(duty * (htim.Init.Period + 1)) - 1u; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; HAL_TIM_PWM_ConfigChannel(&htim, &sConfigOC, channel); this->MspPostInit(r); HAL_TIM_PWM_Start(&htim, channel); return *this; } void TIM::PWMDuty(const uint32_t channel, const float duty) const { *reinterpret_cast<uint32_t*>(reinterpret_cast<uint8_t*>(htim.Instance->CCR1) + (channel - TIM_CHANNEL_1)) = (htim.Init.Period + 1)*duty - 1u; } void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle) { __IO uint32_t tmpreg = 0x00U; SET_BIT(RCC->APB1ENR, 0x1U << (((reinterpret_cast<unsigned>(tim_pwmHandle->Instance) - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_pwmHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); } void TIM::ICInit(int32_t channel, uint32_t ICPolarity, reuse r) { TIM_MasterConfigTypeDef sMasterConfig; TIM_IC_InitTypeDef sConfigIC; this->MspPostInit(r); sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig); sConfigIC.ICPolarity = ICPolarity;//TIM_INPUTCHANNELPOLARITY_RISING; sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI; sConfigIC.ICPrescaler = TIM_ICPSC_DIV1; sConfigIC.ICFilter = 0; HAL_TIM_IC_ConfigChannel(&htim, &sConfigIC, channel); HAL_TIM_IC_Start_IT(&htim, channel); } void HAL_TIM_IC_MspInit(TIM_HandleTypeDef* tim_icHandle) { SET_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); /* Delay after an RCC peripheral clock enabling */ __IO uint32_t tmpreg = READ_BIT(RCC->APB1ENR, 0x1U << ((reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE)) / 0x400U)); UNUSED(tmpreg); HAL_NVIC_SetPriority(static_cast<IRQn_Type>(reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE) / 0x400U + 28), 0, 0); HAL_NVIC_EnableIRQ(static_cast<IRQn_Type>(reinterpret_cast<unsigned>(tim_icHandle->Instance - APB1PERIPH_BASE) / 0x400U + 28)); } extern \"C\" void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM4) { if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) { //HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_1); if (!(photogate.counter++ & 1)) ; TIM_MasterConfigTypeDef sMasterConfig; TIM_IC_InitTypeDef sConfigIC; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(htim, &sMasterConfig); sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING; sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI; sConfigIC.ICPrescaler = TIM_ICPSC_DIV1; sConfigIC.ICFilter = 0; HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, htim->Channel); HAL_TIM_IC_Start_IT(htim, htim->Channel); } } } \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecTIM\u5b9a\u65f6\u5668\u7684\u4f7f\u7528\u548c\u8bbe\u7f6e\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528\u5b9a\u65f6\u5668\u529f\u80fd\u6765\u8fdb\u884c\u673a\u5668\u4eba\u590d\u6742\u529f\u80fd\u4ee3\u7801\u7684\u7f16\u5199\u3002","title":"tim.cpp"},{"location":"USART-Use/","text":"\u4e32\u53e3USART\u901a\u4fe1\u53ef\u4ee5\u652f\u6301\u6211\u4eec\u4f7f\u7528\u4e00\u4e9b\u6269\u5c55\u8bbe\u5907\uff0c\u5982\u9640\u87ba\u4eea\u3001\u9065\u63a7\u5668\u3001\u88c1\u5224\u7cfb\u7edf\u7b49\u7b49 usart.h\u548cusart.cpp\u6587\u4ef6\u7684\u4f7f\u7528 usart.h #pragma once #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_hal_uart.h\" #define UART_MAX_LEN 100 class UART { public: UART& Init(USART_TypeDef* Instance, uint32_t BaudRate); UART& DMATxInit(void); UART& DMARxInit(const uint8_t *buffer = nullptr,const uint32_t size = UART_MAX_LEN); void DMATransmit(uint8_t* pData, uint32_t Size) const; void OnUARTITHandler(uint16_t Size); void OnDMAITHandler(void) const; void RxIdleItCallback(uint16_t rxSize) const; void UARTTransmit(uint8_t* pData, uint32_t Size); static void DMAClearAllFlags(DMA_HandleTypeDef *dmax) { const auto ele = reinterpret_cast<uint32_t>(dmax->Instance); (ele == reinterpret_cast<uint32_t>DMA1_Stream0) ? (DMA1->LIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream1) ? (DMA1->LIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream2) ? (DMA1->LIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream3) ? (DMA1->LIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream4) ? (DMA1->HIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream5) ? (DMA1->HIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream6) ? (DMA1->HIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream7) ? (DMA1->HIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream0) ? (DMA2->LIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream1) ? (DMA2->LIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream2) ? (DMA2->LIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream3) ? (DMA2->LIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream4) ? (DMA2->HIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream5) ? (DMA2->HIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream6) ? (DMA2->HIFCR = 0x003D0000) :\\ (DMA2->HIFCR = 0x0F400000); } UART_HandleTypeDef huart; uint8_t m_uartrx[UART_MAX_LEN]; }; extern UART uart1,uart2, uart4, uart6;// , uart6, uart7; usart.cpp #include \"usart.h\" #include \"RC.h\" #include \"judgement.h\" UART& UART::Init(USART_TypeDef* Instance, const uint32_t BaudRate) { huart.Instance = Instance; huart.Init.BaudRate = BaudRate; huart.Init.WordLength = UART_WORDLENGTH_8B; huart.Init.StopBits = UART_STOPBITS_1; huart.Init.Parity = UART_PARITY_NONE; huart.Init.Mode = UART_MODE_TX_RX; huart.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart); return *this; } UART& UART::DMATxInit(void) { __HAL_DMA_DISABLE(huart.hdmatx); huart.hdmatx->Instance->PAR = reinterpret_cast<uint32_t>(&huart.Instance->DR); huart.hdmatx->Instance->M0AR = 0; DMAClearAllFlags(huart.hdmatx); //\u5f00\u542fDMA\u53d1\u9001\u4e2d\u65ad __HAL_DMA_ENABLE_IT(huart.hdmatx, DMA_IT_TC); SET_BIT(huart.Instance->CR3, USART_CR3_DMAT); return *this; } UART& UART::DMARxInit(const uint8_t *buffer, const uint32_t size) { //\u4f7f\u80fd\u4e32\u53e3DMA\u63a5\u6536 __HAL_DMA_DISABLE(huart.hdmarx); huart.hdmarx->Instance->PAR = reinterpret_cast<uint32_t>(&huart.Instance->DR);//PAR is DMA stream x peripheral address register huart.hdmarx->Instance->NDTR = size; if (buffer == nullptr)buffer = m_uartrx; huart.hdmarx->Instance->M0AR = reinterpret_cast<uint32_t>(buffer); DMAClearAllFlags(huart.hdmarx); __HAL_DMA_ENABLE(huart.hdmarx); SET_BIT(huart.Instance->CR3, USART_CR3_DMAR); //\u5f00\u542f\u4e32\u53e3\u7a7a\u95f2\u4e2d\u65ad __HAL_UART_CLEAR_PEFLAG(&huart); __HAL_UART_ENABLE_IT(&huart, UART_IT_IDLE); return *this; } void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { GPIO_InitTypeDef GPIO_InitStruct; if (uartHandle->Instance == USART1) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART6 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART6 GPIO Configuration PG14 ------> USART6_TX PG9 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA2_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA2_Stream2; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA2_Stream7; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART6 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART1_IRQn); /* DMA interrupt init */ /* DMA2_Stream1_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn); /* DMA2_Stream6_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn); } if (uartHandle->Instance == USART2) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART6 clock enable */ __HAL_RCC_USART2_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART6 GPIO Configuration PG14 ------> USART6_TX PG9 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA1_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA1_Stream5; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA1_Stream6; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART6 interrupt Init */ HAL_NVIC_SetPriority(USART2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART2_IRQn); /* DMA interrupt init */ /* DMA2_Stream1_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn); /* DMA2_Stream6_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn); } if (uartHandle->Instance == UART4) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART1 clock enable */ __HAL_RCC_UART4_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART1 GPIO Configuration PA0 ------> UART4_TX PA1 ------> UART4_RX */ GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF8_UART4; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART1 DMA Init */ __HAL_RCC_DMA1_CLK_ENABLE(); /* USART1_RX Init */ hdma_rx.Instance = DMA1_Stream2; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART1_TX Init */ hdma_tx.Instance = DMA1_Stream4; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(UART4_IRQn, 0, 0); HAL_NVIC_EnableIRQ(UART4_IRQn); /* DMA interrupt init */ /* DMA2_Stream2_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn); /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn); } if (uartHandle->Instance == USART6) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART1 clock enable */ __HAL_RCC_USART6_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); /**USART1 GPIO Configuration PC6 ------> USART6_TX PC7 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF8_USART6; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA2_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA2_Stream1; hdma_rx.Init.Channel = DMA_CHANNEL_5; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA2_Stream6; hdma_tx.Init.Channel = DMA_CHANNEL_5; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART6_IRQn); /* DMA interrupt init */ /* DMA2_Stream2_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn); /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn); } } void UART::RxIdleItCallback(const uint16_t rxSize) const { if (huart.Instance == USART1) { if (nuc.rxData[0] == 'w'&&nuc.rxData[1] == 'h'&&nuc.rxData[2] == 'i'&&nuc.rxData[3] == 'c'&&nuc.rxData[4] == 'h') { if (judgement.ready == true) { uint8_t red[2] = \"R\"; uint8_t blue[2] = \"B\"; if (judgement.data.ext_game_robot_status_t.robot_id < 10) { uart1.UARTTransmit(red, 1); } else { uart1.UARTTransmit(blue, 1); } } } else nuc.OnIRQHandler(rxSize); } if (huart.Instance == USART2) { rc.OnIRQHandler(rxSize); } if (huart.Instance == UART4) { imu.OnIRQHandler(rxSize); } if (huart.Instance == USART6) { judgement.OnIRQHandler(rxSize); } } void UART::OnUARTITHandler(const uint16_t Size = UART_MAX_LEN) { if (__HAL_UART_GET_FLAG(&huart, UART_FLAG_IDLE) && __HAL_UART_GET_IT_SOURCE(&huart, UART_IT_IDLE)) { __HAL_UART_CLEAR_IDLEFLAG(&huart); __HAL_DMA_DISABLE(huart.hdmarx); DMAClearAllFlags(huart.hdmarx); RxIdleItCallback(Size - __HAL_DMA_GET_COUNTER(huart.hdmarx)); __HAL_DMA_SET_COUNTER(huart.hdmarx, Size); __HAL_DMA_ENABLE(huart.hdmarx); } HAL_UART_IRQHandler(&huart); } void UART::OnDMAITHandler(void) const { UART::DMAClearAllFlags(huart.hdmatx); __HAL_DMA_DISABLE(huart.hdmatx); } extern \"C\" void USART1_IRQHandler(void) { uart1.OnUARTITHandler(); } extern \"C\" void USART2_IRQHandler(void) { uart2.OnUARTITHandler(); } //extern \"C\" void USART6_IRQHandler(void) //{ // uart6.OnUARTITHandler(); //} extern \"C\" void UART4_IRQHandler(void) { uart4.OnUARTITHandler(); } extern \"C\" void USART6_IRQHandler(void)//Question { uart6.OnUARTITHandler(); } extern \"C\" void DMA1_Stream2_IRQHandler(void) { } extern \"C\" void DMA1_Stream4_IRQHandler(void) { uart4.OnDMAITHandler(); } extern \"C\" void DMA2_Stream6_IRQHandler(void) { uart6.OnDMAITHandler(); } void UART::DMATransmit(uint8_t*const pData, const uint32_t Size) const { __HAL_DMA_DISABLE(huart.hdmatx); huart.hdmatx->Instance->NDTR = Size; huart.hdmatx->Instance->M0AR = reinterpret_cast<uint32_t>(pData); DMAClearAllFlags(huart.hdmatx); __HAL_DMA_ENABLE(huart.hdmatx); } void UART::UARTTransmit(uint8_t* pData, uint32_t Size) { HAL_UART_Transmit(&huart, static_cast<uint8_t*>(pData), Size, 0xffff); } extern \"C\" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecUSART\u901a\u4fe1\u7684\u6536\u53d1\u65b9\u5f0f\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528USART\u901a\u4fe1\u6765\u8fdb\u884c\u6269\u5c55\u6a21\u5757\u4ee3\u7801\u7684\u7f16\u5199\u3002","title":"USART"},{"location":"USART-Use/#usarthusartcpp","text":"","title":"usart.h\u548cusart.cpp\u6587\u4ef6\u7684\u4f7f\u7528"},{"location":"USART-Use/#usarth","text":"#pragma once #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_hal_uart.h\" #define UART_MAX_LEN 100 class UART { public: UART& Init(USART_TypeDef* Instance, uint32_t BaudRate); UART& DMATxInit(void); UART& DMARxInit(const uint8_t *buffer = nullptr,const uint32_t size = UART_MAX_LEN); void DMATransmit(uint8_t* pData, uint32_t Size) const; void OnUARTITHandler(uint16_t Size); void OnDMAITHandler(void) const; void RxIdleItCallback(uint16_t rxSize) const; void UARTTransmit(uint8_t* pData, uint32_t Size); static void DMAClearAllFlags(DMA_HandleTypeDef *dmax) { const auto ele = reinterpret_cast<uint32_t>(dmax->Instance); (ele == reinterpret_cast<uint32_t>DMA1_Stream0) ? (DMA1->LIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream1) ? (DMA1->LIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream2) ? (DMA1->LIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream3) ? (DMA1->LIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream4) ? (DMA1->HIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream5) ? (DMA1->HIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream6) ? (DMA1->HIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA1_Stream7) ? (DMA1->HIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream0) ? (DMA2->LIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream1) ? (DMA2->LIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream2) ? (DMA2->LIFCR = 0x003D0000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream3) ? (DMA2->LIFCR = 0x0F400000) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream4) ? (DMA2->HIFCR = 0x0000003D) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream5) ? (DMA2->HIFCR = 0x00000F40) :\\ (ele == reinterpret_cast<uint32_t>DMA2_Stream6) ? (DMA2->HIFCR = 0x003D0000) :\\ (DMA2->HIFCR = 0x0F400000); } UART_HandleTypeDef huart; uint8_t m_uartrx[UART_MAX_LEN]; }; extern UART uart1,uart2, uart4, uart6;// , uart6, uart7;","title":"usart.h"},{"location":"USART-Use/#usartcpp","text":"#include \"usart.h\" #include \"RC.h\" #include \"judgement.h\" UART& UART::Init(USART_TypeDef* Instance, const uint32_t BaudRate) { huart.Instance = Instance; huart.Init.BaudRate = BaudRate; huart.Init.WordLength = UART_WORDLENGTH_8B; huart.Init.StopBits = UART_STOPBITS_1; huart.Init.Parity = UART_PARITY_NONE; huart.Init.Mode = UART_MODE_TX_RX; huart.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart); return *this; } UART& UART::DMATxInit(void) { __HAL_DMA_DISABLE(huart.hdmatx); huart.hdmatx->Instance->PAR = reinterpret_cast<uint32_t>(&huart.Instance->DR); huart.hdmatx->Instance->M0AR = 0; DMAClearAllFlags(huart.hdmatx); //\u5f00\u542fDMA\u53d1\u9001\u4e2d\u65ad __HAL_DMA_ENABLE_IT(huart.hdmatx, DMA_IT_TC); SET_BIT(huart.Instance->CR3, USART_CR3_DMAT); return *this; } UART& UART::DMARxInit(const uint8_t *buffer, const uint32_t size) { //\u4f7f\u80fd\u4e32\u53e3DMA\u63a5\u6536 __HAL_DMA_DISABLE(huart.hdmarx); huart.hdmarx->Instance->PAR = reinterpret_cast<uint32_t>(&huart.Instance->DR);//PAR is DMA stream x peripheral address register huart.hdmarx->Instance->NDTR = size; if (buffer == nullptr)buffer = m_uartrx; huart.hdmarx->Instance->M0AR = reinterpret_cast<uint32_t>(buffer); DMAClearAllFlags(huart.hdmarx); __HAL_DMA_ENABLE(huart.hdmarx); SET_BIT(huart.Instance->CR3, USART_CR3_DMAR); //\u5f00\u542f\u4e32\u53e3\u7a7a\u95f2\u4e2d\u65ad __HAL_UART_CLEAR_PEFLAG(&huart); __HAL_UART_ENABLE_IT(&huart, UART_IT_IDLE); return *this; } void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { GPIO_InitTypeDef GPIO_InitStruct; if (uartHandle->Instance == USART1) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART6 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART6 GPIO Configuration PG14 ------> USART6_TX PG9 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA2_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA2_Stream2; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA2_Stream7; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART6 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART1_IRQn); /* DMA interrupt init */ /* DMA2_Stream1_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn); /* DMA2_Stream6_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn); } if (uartHandle->Instance == USART2) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART6 clock enable */ __HAL_RCC_USART2_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART6 GPIO Configuration PG14 ------> USART6_TX PG9 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA1_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA1_Stream5; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA1_Stream6; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART6 interrupt Init */ HAL_NVIC_SetPriority(USART2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART2_IRQn); /* DMA interrupt init */ /* DMA2_Stream1_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn); /* DMA2_Stream6_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn); } if (uartHandle->Instance == UART4) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART1 clock enable */ __HAL_RCC_UART4_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART1 GPIO Configuration PA0 ------> UART4_TX PA1 ------> UART4_RX */ GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF8_UART4; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); /* USART1 DMA Init */ __HAL_RCC_DMA1_CLK_ENABLE(); /* USART1_RX Init */ hdma_rx.Instance = DMA1_Stream2; hdma_rx.Init.Channel = DMA_CHANNEL_4; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART1_TX Init */ hdma_tx.Instance = DMA1_Stream4; hdma_tx.Init.Channel = DMA_CHANNEL_4; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(UART4_IRQn, 0, 0); HAL_NVIC_EnableIRQ(UART4_IRQn); /* DMA interrupt init */ /* DMA2_Stream2_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn); /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn); } if (uartHandle->Instance == USART6) { static DMA_HandleTypeDef hdma_rx; static DMA_HandleTypeDef hdma_tx; /* USART1 clock enable */ __HAL_RCC_USART6_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); /**USART1 GPIO Configuration PC6 ------> USART6_TX PC7 ------> USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF8_USART6; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); /* USART6 DMA Init */ __HAL_RCC_DMA2_CLK_ENABLE(); /* USART6_RX Init */ hdma_rx.Instance = DMA2_Stream1; hdma_rx.Init.Channel = DMA_CHANNEL_5; hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_rx.Init.Mode = DMA_NORMAL; hdma_rx.Init.Priority = DMA_PRIORITY_LOW; hdma_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_rx); __HAL_LINKDMA(uartHandle, hdmarx, hdma_rx); /* USART6_TX Init */ hdma_tx.Instance = DMA2_Stream6; hdma_tx.Init.Channel = DMA_CHANNEL_5; hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_tx.Init.Mode = DMA_NORMAL; hdma_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_Init(&hdma_tx); __HAL_LINKDMA(uartHandle, hdmatx, hdma_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART6_IRQn); /* DMA interrupt init */ /* DMA2_Stream2_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn); /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn); } } void UART::RxIdleItCallback(const uint16_t rxSize) const { if (huart.Instance == USART1) { if (nuc.rxData[0] == 'w'&&nuc.rxData[1] == 'h'&&nuc.rxData[2] == 'i'&&nuc.rxData[3] == 'c'&&nuc.rxData[4] == 'h') { if (judgement.ready == true) { uint8_t red[2] = \"R\"; uint8_t blue[2] = \"B\"; if (judgement.data.ext_game_robot_status_t.robot_id < 10) { uart1.UARTTransmit(red, 1); } else { uart1.UARTTransmit(blue, 1); } } } else nuc.OnIRQHandler(rxSize); } if (huart.Instance == USART2) { rc.OnIRQHandler(rxSize); } if (huart.Instance == UART4) { imu.OnIRQHandler(rxSize); } if (huart.Instance == USART6) { judgement.OnIRQHandler(rxSize); } } void UART::OnUARTITHandler(const uint16_t Size = UART_MAX_LEN) { if (__HAL_UART_GET_FLAG(&huart, UART_FLAG_IDLE) && __HAL_UART_GET_IT_SOURCE(&huart, UART_IT_IDLE)) { __HAL_UART_CLEAR_IDLEFLAG(&huart); __HAL_DMA_DISABLE(huart.hdmarx); DMAClearAllFlags(huart.hdmarx); RxIdleItCallback(Size - __HAL_DMA_GET_COUNTER(huart.hdmarx)); __HAL_DMA_SET_COUNTER(huart.hdmarx, Size); __HAL_DMA_ENABLE(huart.hdmarx); } HAL_UART_IRQHandler(&huart); } void UART::OnDMAITHandler(void) const { UART::DMAClearAllFlags(huart.hdmatx); __HAL_DMA_DISABLE(huart.hdmatx); } extern \"C\" void USART1_IRQHandler(void) { uart1.OnUARTITHandler(); } extern \"C\" void USART2_IRQHandler(void) { uart2.OnUARTITHandler(); } //extern \"C\" void USART6_IRQHandler(void) //{ // uart6.OnUARTITHandler(); //} extern \"C\" void UART4_IRQHandler(void) { uart4.OnUARTITHandler(); } extern \"C\" void USART6_IRQHandler(void)//Question { uart6.OnUARTITHandler(); } extern \"C\" void DMA1_Stream2_IRQHandler(void) { } extern \"C\" void DMA1_Stream4_IRQHandler(void) { uart4.OnDMAITHandler(); } extern \"C\" void DMA2_Stream6_IRQHandler(void) { uart6.OnDMAITHandler(); } void UART::DMATransmit(uint8_t*const pData, const uint32_t Size) const { __HAL_DMA_DISABLE(huart.hdmatx); huart.hdmatx->Instance->NDTR = Size; huart.hdmatx->Instance->M0AR = reinterpret_cast<uint32_t>(pData); DMAClearAllFlags(huart.hdmatx); __HAL_DMA_ENABLE(huart.hdmatx); } void UART::UARTTransmit(uint8_t* pData, uint32_t Size) { HAL_UART_Transmit(&huart, static_cast<uint8_t*>(pData), Size, 0xffff); } extern \"C\" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } \u5c06\u6211\u4eec\u7684\u9879\u76ee\u6587\u4ef6\u6dfb\u52a0\u5982\u4e0a\u4e24\u4e2a\u6587\u4ef6\uff0c\u6587\u4ef6\u4e2d\u5305\u62ecUSART\u901a\u4fe1\u7684\u6536\u53d1\u65b9\u5f0f\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u6211\u4eec\u4f7f\u7528USART\u901a\u4fe1\u6765\u8fdb\u884c\u6269\u5c55\u6a21\u5757\u4ee3\u7801\u7684\u7f16\u5199\u3002","title":"usart.cpp"}]}